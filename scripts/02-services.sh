#!/usr/bin/env bash
# 02-services.sh - Application orchestrator
# Dynamically loads and installs apps from the apps/ directory
set -euo pipefail

SCRIPT_DIR="${SCRIPT_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)}"

# Source libraries
# shellcheck source=../lib/common.sh
source "${SCRIPT_DIR}/lib/common.sh"
# shellcheck source=../lib/security.sh
source "${SCRIPT_DIR}/lib/security.sh"
# shellcheck source=../lib/whitelist.sh
source "${SCRIPT_DIR}/lib/whitelist.sh"

# Load configuration
load_config

# Track firewall ports to open
FIREWALL_PORTS_TO_ADD=()

install_app_dependencies() {
    local app_name="$1"

    log_info "Installing dependencies for $app_name..."

    # Get dependencies from app
    local deps
    deps=$(app_dependencies 2>/dev/null || echo "")

    if [[ -n "$deps" ]]; then
        # shellcheck disable=SC2086
        apt-get install -y $deps
        log_success "Dependencies installed for $app_name"
    fi
}

register_app_ports() {
    local app_name="$1"

    # Get ports from app
    local ports
    ports=$(app_ports 2>/dev/null || echo "")

    if [[ -n "$ports" ]]; then
        for port in $ports; do
            log_info "Registering port $port for $app_name"
            FIREWALL_PORTS_TO_ADD+=("$port")
        done
    fi
}

open_firewall_ports() {
    if [[ ${#FIREWALL_PORTS_TO_ADD[@]} -eq 0 ]]; then
        log_info "No additional firewall ports to open"
        return 0
    fi

    log_info "Opening firewall ports for installed apps..."

    for port in "${FIREWALL_PORTS_TO_ADD[@]}"; do
        if ! ufw status | grep -q "${port}"; then
            ufw allow "$port" comment "App port"
            log_info "Opened port: $port"
        else
            log_info "Port $port already open"
        fi
    done

    log_success "Firewall ports configured"
}

install_app() {
    local app_name="$1"
    local app_file="${APPS_DIR}/${app_name}.sh"

    if [[ ! -f "$app_file" ]]; then
        log_error "App file not found: $app_file"
        return 1
    fi

    log_info "========================================"
    log_info "Installing app: $app_name"
    log_info "========================================"

    # Source the app file
    # shellcheck source=/dev/null
    source "$app_file"

    # Display app info
    local info
    info=$(app_info 2>/dev/null || echo "")
    if [[ -n "$info" ]]; then
        log_info "App info:"
        echo "$info" | while IFS= read -r line; do
            log_info "  $line"
        done
    fi

    # Install dependencies
    install_app_dependencies "$app_name"

    # Run installation
    if ! app_install; then
        log_error "Failed to install $app_name"
        return 1
    fi

    # Run configuration
    if ! app_configure; then
        log_error "Failed to configure $app_name"
        return 1
    fi

    # Register ports for firewall
    register_app_ports "$app_name"

    log_success "App $app_name installed successfully"
}

create_service_scripts() {
    log_info "Creating service management scripts..."

    local enabled_apps="${ENABLED_APPS}"

    cat > /opt/minipc/scripts/servicectl.sh << 'HEADER'
#!/bin/bash
# Service management helper - auto-generated by headless-setup
# Usage: ./servicectl.sh [start|stop|restart|status] [service|all]

ACTION="${1:-status}"
SERVICE="${2:-all}"

HEADER

    # Build case statement dynamically
    {
        echo "case \"\$SERVICE\" in"

        for app in $enabled_apps; do
            echo "    $app)"
            echo "        sudo systemctl \$ACTION $app"
            echo "        ;;"
        done

        echo "    all)"
        for app in $enabled_apps; do
            echo "        sudo systemctl \$ACTION $app"
        done
        echo "        ;;"

        echo "    *)"
        echo "        echo \"Unknown service: \$SERVICE\""
        echo "        echo \"Available: ${enabled_apps} all\""
        echo "        exit 1"
        echo "        ;;"
        echo "esac"
    } >> /opt/minipc/scripts/servicectl.sh

    chmod +x /opt/minipc/scripts/servicectl.sh

    log_success "Service management script created at /opt/minipc/scripts/servicectl.sh"
}

main() {
    log_info "=== Starting 02-services.sh ==="
    log_info "Enabled apps: ${ENABLED_APPS}"

    # Install each enabled app
    for app in ${ENABLED_APPS}; do
        install_app "$app"
    done

    # Open firewall ports for all apps
    open_firewall_ports

    # Build openclaw whitelist from all app declarations
    build_openclaw_whitelist

    # Create service management helper
    create_service_scripts

    log_success "=== 02-services.sh complete ==="
    log_info "Installed apps: ${ENABLED_APPS}"
    log_info "Use /opt/minipc/scripts/servicectl.sh to manage services"
}

main
